# V8 的调试工具 D8 的使用

brew install v8 // mac 安装 v8 后自带 d8

```
d8 --help
// 字节码
d8 test.js --print-bytecode
// 查看代码优化
d8 --trace-opt-verbose test.js
// 查看gc
d8 --trace-gc test.js
// 内部方法，然后在js代码中 '%GetHeapUsage()'使用该方法
--allow-natives-syntax
```

# Node 调试

```
node --inspect-brk add.js
chrome://inspect
点击inspect
```

[更多 V8 内部方法](https://github.com/v8/v8/blob/4b9b23521e6fd42373ebbcb20ebe03bf445494f9/src/runtime/runtime.h)

# JS 代码是如何被浏览器引擎编译、执行的

![](../img/v8-life.png)

## 编译型语言 && 解释型语言

1.  编译型语言的特点是在代码运行前编译器直接将对应的代码转换成机器码，运行时不需要再重新翻译，直接可以使用编译后的结果(Java 和 C++ )。

2.  解释型语言也是需要将代码转换成机器码，但是和编译型的区别在于运行时需要转换。比较显著的特点是，解释型语言的执行速度要慢于编译型语言，因为解释型语言每次执行都需要把源码转换一次才能执行(JavaScript 和 ruby)。

## V8 引擎执行 JS 代码都要经过哪些阶段？

1.  Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）；
2.  Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；
3.  TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；
4.  Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。

### 代码到 AST

生成 AST 分为两个阶段，一是词法分析，二是语法分析，我们来分别看下这两个阶段的情况。
[AST 在线生成工具](https://astexplorer.net/)

1.  词法分析：这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a = 1；通常会被分解成 var 、a、=、1、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。
2.  语法分析：这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。

### 生成字节码

将抽象语法树转换为字节码，也就是上面提到的 Ignition 阶段。
其实字节码是介于 AST 和机器码之间的一种代码，需要将其转换成机器码后才能执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。

### 生成机器码

在 Ignition 解释器处理完之后，如果发现一段代码被重复执行多次的情况，生成的字节码以及分析数据会传给 TurboFan 编译器，它会根据分析数据的情况生成优化好的机器码。再执行这段代码之后，只需要直接执行编译后的机器码，这样性能就会更好。

# V8 工作原理

V8 is Google's open source JavaScript engine.

## Handle

handle 是指向对象的指针，在 V8 中，所有的对象都通过 handle 来引用，handle 主要用于 V8 的垃圾回收机制。<br>
handle 分为两种：持久化 (Persistent)handle 和本地 (Local)handle，持久化 handle 存放在堆上，而本地 handle 存放在栈上。<br>
在 V8 中，所有数据访问均需要通过 handle。<br>

### 在 C++中栈 Stack 和堆 Heap

Stack：栈上的为自动变量，在退出函数或方法之后自动被释放。<br>
Heap：堆上的空间需要开发人员自己申请，使用完成之后显式的释放。<br>

## HandleScope

一个函数中，可以有很多 Handle，而 HandleScope 则相当于用来装 Handle（Local）的容器，当 HandleScope 生命周期结束的时候，Handle 也将会被释放，会引起 Heap 中对象引用的更新。<br>
HandleScope 是分配在栈上，不能通过 New 的方式进行创建。对于同一个作用域内可以有多个 HandleScope，新的 HandleScope 将会覆盖上一个 HandleScope，并对 Local Handle 进行管理。<br>

## Context

Context 是 V8 中一个非常重要的类。<br>
Context 中包了 JavaScript 内建函数、对象等。<br>
context 是一个执行器环境，使用 context 可以将相互分离的 JavaScript 脚本在同一个 V8 实例中运行，而互不干涉。在运行 JavaScript 脚本时，需要显式的指定 context 对象。

## 数据及模板

由于 C++ 原生数据类型与 JavaScript 中数据类型有很大差异，
因此 V8 提供了 Data 类，从 JavaScript 到 C++，从 C++ 到 JavaScrpt 都会用到这个类及其子类。<br>
V8 中，有两个模板 (Template) 类：对象模板 (ObjectTempalte) 和函数模板 (FunctionTemplate):<br>
ObjectTemplate：将 C++ 中的对象暴露给脚本环境<br>
FunctionTemplate：将 C++ 函数暴露给脚本环境，以供脚本使用

## V8 引擎的应用程序的基本流程

1.  创建 HandleScope 实例
2.  创建一个持久化的 Context
3.  进入 Context
4.  创建脚本字符串（这里就是我们的 js 代码）
5.  创建 Script 对象，通过 Script::Compile()
6.  执行脚本对象的 Run 方法
7.  获取处理结果
8.  显式的调用 Context 的 Dispose 方法

## TurboFan & Ignition

其中 Turbofan 是新的优化编译器，而 Ignition 则是新的解释器。

[Google V8 引擎 原理详解](https://blog.csdn.net/jklfjsdj79hiofo/article/details/7842177)

# 对象（Object）

## 对象两种访问模式

### Dictionary(Slow) Mode

字典模式也称为哈希表模式，V8 使用哈希表来存储对象的属性。

### Stable(Fast) Mode

使用类似数组（C Struct）结构来存储对象的属性并使用 Offset 进行访问。

### 访问模式切换

#### 快速模式切换至字典模式

1.  当动态地添加太多属性
2.  删除属性（删除非最后添加的属性 V8 >= 6.0）
3.  使用不合法标识符命名属性

#### 字典模式切换至快速模式

1.  调用 Runtime Call (%ToFastProperties)
2.  当对象被设置成为一个函数（或对象）的原型
    [奇技淫巧学 V8 之一，对象访问模式优化](https://zhuanlan.zhihu.com/p/28777722)

## 对象在 V8 内的表达

### 对象存储空间分配

1.  预分配（不超过）一定大小（252）的空间用作对象内属性存储（inobject_properties）。
2.  预分配空间不足时（无空闲 slot），新增属性会存储在 properties 内。
3.  数字式属性存储在 elements 内。
4.  properties/elements 空间不足时会创建（拷贝）一个更大的 FixedArray。
    V8 的对象主要由三个指针构成，分别是隐藏类（Hidden Class、Shape），Property 还有 Element。<br>
    [奇技淫巧学 V8 之二，对象在 V8 内的表达](https://zhuanlan.zhihu.com/p/28780798)

### Hidden class（Shape）

引擎将对象的 Shape 与对象值分开存储。<br>
V8 会为每个对象初始化时附加一个隐藏类，隐藏类的目的是优化属性访问时间，当添加一个属性时（非索引属性），会产生一个新的隐藏类，该隐藏类继承至原先的隐藏类。<br>
主要为类似的对象（同一构造函数、类的实例，主要是保证相同的顺序初始化对象成员）提供相同的 Shape，用来提升属性的存取性能。<br>
每次添加属性时，新创建 Hidden Class 实际上只会描述这个新添加的属性（增加或删除可索引属性，不会引起隐藏类的变化）。<br>
delete 非索引属性可以会产生新的 Hidden Class ，而 obj[待删除的属性] = undefined 不会 <br>
[V8 中的 Javascript 隐藏类和内联缓存](https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html)

#### Hidden Class 如何优化了对象属性的访问性能？

1.  Hidden Class 描述了可以找到属性的内存中的位置（相对于对象指针），V8 把属性 field 的按名字访问，抹掉名字信息，变成按 offset 访问。
2.  如果两个对象添加属性的顺序相同，则他们共用一个 Hidden Class，这样就可以快速访问属性
3.  每次新增属性会在原来的 Hidden Class 基础上新建一个 Hidden Class（这样就形成了 shape 链或树），Hidden Class 只记录了当前属性 offset 及除[[value]]以外的属性

### Elements

可索引属性会被存储到 Elements 指针指向的区域（遍历时会自动按升序）<br>

```
{ 1: "a", 2: "b" }
```

### Properties

命名属性会被存储到 Properties 指针指向的区域（会按写入对象的顺序）<br>

```
{ "first": 1, "second": 2 }
```

[V8 是怎么跑起来的 —— V8 中的对象表示](https://juejin.im/post/5cc7dc5af265da038d0b514d)

## Inline Cache（内联缓存）

### 定义

内联缓存（Inline caching）是部分编程语言的运行时系统采用的优化技术，最早为 Smalltalk 开发。内联缓存的目标是通过记住以前直接在调用点上方法查询的结果来加快运行时方法绑定的速度。内联缓存对动态类型语言尤为有用，其中大多数（如非全部）方法绑定发生在运行时，因此虚方法表通常无法使用。<br>
内联缓存分为：单态内联缓存、多态内联缓存、变形内联缓存，单态调用（MONOMORPHIC）性能优于多态（POLYMORPHIC）与复态（MEGAMORPHIC）！<br>

### 单态内联缓存、多态内联缓存、变形内联缓存转换关系

区别：对于特定调用（callsite） 来说 receiver 类型（shape）数量不同，而呈现不同状态。<br>

```
当 IC 刚被创建时为初态（没有调用过），没有接收到任何一种类型信息。
当被调用时：
如果接收到 1 种类型信息会迁移到单态模式（MONOMORPHIC）。
收到大于 1 种小于 4 种类型信息会迁移到多态模式（POLYMORPHIC）。
当接收到大于 4 种类型信息时会迁移到复态模式（MEGAMORPHIC）。
```

PS：kMaxKeyedPolymorphism = 4，所以多态与复态模式模式的界限在接收到 4 种类型信息时。

### 工作原理

Shapes 背后的主要动机是 Inline Caches 或 ICs 的概念，JS 引擎为了提高对象查找效率，需要在局部做高效缓存。<br>
如在对象上读属性时第一次去查找 shape 链，找到相应属性的 offset，再次访问属性，只要 Shape 相同，引擎直接从指令中缓存的下标中可以直接命中要查找的值，而这个缓存在指令中的下标就是 Inline Cache 下次直接使用。

```
// 对象 a 和 b 拥有相同的 shape（记录了当前属性offset及除[[value]]以外的属性）
var a = {x: 'yzf'};
var b = {x: 'wkm'};
// 定义访问对象属性的方法
function getX(point) {
  // point.x称为 callsite
  return point.x;
}
// 我们把 point.x 称之为一个 callsite，把 "x" 称之为一条名为 "x" 的消息，而实际执行的 point （无论是 {x : 1}，还是 {x : 1, y : 2}）称之为这个 callsite 的 receiver。
// 初次访问 x 属性，在 shape 链或树找到对 x 属性的描述offset，并缓存起来（Inline Cache）
getX(a);
// 再次访问其他对象的 x 属性，不需要再查找 shape 链或树，直接命中要查找的值
getX(b);
```

### 内联缓存和 Hidden Class 需要配合工作

每当在特定对象上调用方法时，V8 引擎必须执行对该对象隐藏类的查找，以确定访问特定属性的偏移量。在将同一方法成功调用两次到同一个隐藏类之后，V8 省略了隐藏类查找，只是将属性的偏移量添加到对象指针本身。对于该方法的所有未来调用，V8 引擎假定隐藏类未更改，并使用先前查找中存储的偏移直接跳转到特定属性的内存地址; 这大大提高了执行速度。
[内联缓存](https://zh.wikipedia.org/wiki/%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98)
[奇技淫巧学 V8 之三，多态内联缓存 PICs](https://zhuanlan.zhihu.com/p/28790195)

## 对象优化

始终以相同的顺序实例化对象属性，以便可以共享隐藏的类和随后优化的代码。<br>
在实例化之后向对象添加属性将强制隐藏类更改并减慢为先前隐藏类优化的任何方法。而是在其构造函数中分配所有对象的属性。<br>
沿着属性添加的反方向删除属性时，对象不会退化为字典模式。<br>
重复执行相同方法的代码将比仅执行许多不同方法的代码运行得更快（由于内联缓存）。<br>

# 原型优化（prototype）

引擎将原型链在 Shape 上，而不是直接链在实例上。<br>
V8 专门为此目的处理原型的 shape。每个原型都具有一个不与其他对象（特别是不与其他原型共享）共享且独特的 shape，且每个原型的 shape 都具有与之关联的一个特殊 ValidityCell。<br>
只要有人更改相关原型或其祖先的任何原型，此 ValidityCell 就会失效。<br>
第一次运行此代码预热 inline cache 时，V8 会记住目标属性在原型中的偏移量。下次 inline cache 命中时，引擎必须检查实例的 shape 和 ValidityCell。如果 ValidityCell === true，则引擎可以直接到达 Prototype 上的 Offset 位置，跳过其他查找。如果它 ValidityCell === false，引擎将重复上面的操作。<br>

## 优化

1. 请勿随意修改原型对象（这样是使引擎的优化手段失效）
2. 你实在需要修改原型，那么请在其他代码运行之前做这件事

[JavaScript 引擎基础：原型优化](https://zhuanlan.zhihu.com/p/42630183)

# 数组（Array）

## V8 引擎将 JavaScript 数组分为两类

### FixedArray

FixedArray，使用连续的内存进行存储，可以使用索引直接定位，新创建的空数组默认为 FixedArray 类型，当数组超过最大长度会进行动态地扩容；

### HashTable

HashTable，以哈希表的形式存储在内存空间里，存储地址不连续，与 FixedArray 类型相比，性能相对较差。

### 两者之间在实际使用时可以相互转换

FixedArray 转 HashTable，当新增元素的索引值相对于数组长度大于等于 1024 或者新容量 >= 3 × 扩容后的容量 × 2；
HashTable 转 FixedArray，当 HashTable 数组的元素可存放在 FixedArray 数组中且长度在 smi 之间且仅节省了 50% 的空间时发生转换，其中 smi 值在不同操作系统下有所不同。

## TimSort 排序

Array.prototype.sort() 函数的底层实现算法 TimSort。<br>
JavaScript 引擎把高效的排序算法写入数组的原型函数 sort 中了，这种高效的排序算法就是 TimSort。<br>
TimSort 同时采用了折半插入排序和归并排序。<br>
时间复杂度可以达到 O(n)，最坏的情况下也能达到 O(nlogn)，空间复杂度在最好情况和最坏情况下分别为 O(1) 和 O(n)。

## 数组存储模式

Fast Elements 是传统的线性存储方式，而 Dictionary Elements 使用的是 Hash 表存储。<br>
Fast Elements：该模式为默认模式，对于一个新创建的数组赋值时，数组的存储空间是可以动态增长的。<br>
Fast Holey Elements：Fast Elements 还有一种子模式 Fast Holey Elements，此模式适合于数组中只有某些索引存有元素，而其他的索引都没有赋值的情况（访问时引擎会返回 undefined）。<br>
Dictionary Elements：此方式最适合于存储稀疏数组，它不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 Hash-Table。<br>

## 存储模式切换

其上的几种模式 V8 引擎可以自由切换。<br>
在 Fast Elements 模式下，capacity 用于指示当前内存占用量大小，通常根据数组当前最大索引的值确定。在数组索引过大，超过 capacity 到一定程度( 由 kMaxGap 决定，其值为 1024) ，数组将直接转化为 Dictionary Elements 模式。

## 数组性能优化

避免使用负整数作为索引<br>
预先指定数组大小<br>
避免使用不连续的索引值<br>
避免逆序对数组赋值<br>
避免读数超出数组的长度！这样 V8 会在原型链上去找这个属性。<br>
避免产生 holey 数组（如 new Array(100)），v8 对密集数组做了更多优化。<br>
[V8 引擎中的 JavaScript 数组实现分析与性能优化](https://blog.csdn.net/xiebaochun/article/details/85711635)

# 字符串（String）

## v8 中字符串 5 种表达模式

### SeqString

在 V8 堆内使用（类似数组的）连续空间存储字符串。
实际数据存储时分为 OneByte(全是单字节字符)、TwoByte(有双字节字符)（Unicode）两类。

### ConsString(first, second)

在字符串拼接时，采用树形结构表达拼接后（first + second）的字符串。

### SliceString(parent, offset)

在字符串切割时，采用 offset 与 [length] 表达父字符串（parent）的一部分。

### ThinString(actual)

直接引用另一个字符串对象（actual）。
在多数情况下可以被认为与 ConsString(actual, empty_string) 等价。

### ExternalString

代表了产生在 V8 堆外的字符串资源。
实际数据表达时分为 OneByte、TwoByte（Unicode）两类。<br>
所有的表达模式均有 [length] 属性（由基类 String 定义）记录了字符串中的字符数（UTF-16 单元数），但只有 SeqString 真正存储了字符数据，而 ConsString 、SliceString 、ThinString 均为其它表达模式的引用（不存储字符数据）。

## 字符串性能优化

字符串的表达方式大多与其构造方式有关。<br>
字符串拼接时，比起重新分配一个空间进行存储，采用树形结构（ConsString）表达更加高效。<br>
字符串在最终输出前调用 Number 方法来扁平化，可以提高后续操作的性能。<br>
将字符串被设置为对象属性名时，会被尝试改造为常量化版本。

[奇技淫巧学 V8 之六，字符串在 V8 内的表达](https://zhuanlan.zhihu.com/p/28883711)

# 数字（Number）

JavaScript 值，V8 仍需要对不同类型值应用特定的内存表示方式。

### 三种存储方式

Smi vs HeapNumber vs MutableHeapNumber<br>

#### Smi

范围：64 位-2³¹ 到 2³¹-1<br>
Smi:immediate small integer<br>
31 位有符号位范围内的整型数字都用 Smi 表示法。
当使用 Smi 内的数字时，引擎不需要为其分配专门的内存实体，并会启用快速整型操作。<br>

#### HeapNumber

浮点数会用 HeapNumber 表示。
非 Smi 范围内的数字被定义为 HeapNumber，HeapNumber 是一种特殊的 HeadObject。<br>

#### MutableHeapNumber

```
const o = {
  x: 42,  // Smi，会被当成Smi直接存储在对象本身
  y: 4.2, // HeapNumber，o.y中的4.2需要额外开辟一个内存实体存放，并将o.y的对象指针指向该内存实体
  z: 5.2 // HeapNumber
};

// 对象操作
o.x = o.x + 10; // o.x = 52,o.x的值会被原地更新，因为新的值52仍在Smi范围中。
o.y += 1; // 而HeapNumber是不可变的，当我们改变o.y的值为5.2时，V8 需要再开辟一个新的内存实体给到o.y引用。
for (let i = 0; i < 5; ++i) {
  // 创建一个额外的`HeapNumber`对象
  o.z += 1; // 优化后编程了一个MutableHeapNumber实例
}
// 为了防止这个问题（每次循环都创建HeapNumber实例），V8 提供了一种优化方式去原地更新非Smi的值：当一个数字内存区域拥有一个非Smi范围内的数值时，V8 会将这块区域标志为Double区域，并会为其分配一个用 64 位浮点表示的MutableHeapNumber实例。
o.w = o.z;
// 当o.z被共享时，o.z内的MutableHeapNumber需要被重新封装成HeapNumber
```

# JIT 和 AOT

## AOT

AOT：静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为 AOT （Ahead of time）即 “提前编译”，代表 C/C++。

## JIT

JIT：解释执行的则是一句一句边翻译边运行，通常将这种类型称为 JIT（Just-in-time）即“即时编译”，代表 JavaScript、python。

事实上所有脚本语言都支持 JIT 模式。但需要注意的是 JIT 和 AOT 指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以 JIT 方式运行也可以以 AOT 方式运行，如 Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码。

# V8 的内存分配（垃圾回收）

以 64 位为例子：V8 能够获得 1.4G<br>
垃圾回收会终止程序执行。

```
// 这是调整新生代这部分的内存，单位是 KB。
node --max_new_space_size=2048 xxx.js
// 这是调整老生代这部分的内存，单位是MB
node --max_old_space_size=2048 xxx.js
```

## V8 为什么要给它设置内存上限？

1.  JS 单线程的执行机制（这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停）
2.  JS 垃圾回收机制的限制（垃圾回收其实是非常耗时间的操作，采用增量标记方式得以缓解）

## 新生代内存（算法名 Scavenge 算法）

新生代内存空间（短时间存在的，如局部变量）：64MB<br>
垃圾回收算法：遍历标记，标记即将回收的对象，复制未标记的对象，交换空间

1.  首先，V8 引擎中的垃圾回收器检测到 from space 空间快达到上限了，此时要进行一次垃圾回收了
2.  然后，从根部开始遍历，不可达对象(即无法遍历到的对象)将会被标记，并且复制未被标记的对象，放到 to space 中
3.  最后，清除 from space 中的数据，同时将 from space 置为空闲状态，即变成 to space，相应的 to space 变成 from space，俗称翻转

## old Space 回收

新生代遍历使用广度优先遍历，老生代遍历使用深度优先遍历。

## 引用计数算法（Reference Counter）

如果一个节点的引用计数是 0，就意味着没有任何一个节点引用它——此时，理论上这个节点应该被回收。GC 不断扫描引用计数为 0 的节点进行回收，就构成了最简单的一个内存回收算法。

存在问题

1.  循环引用，导致 GC 始终不会回收它们。
2.  引用计数法容错能力差，一旦计算错了（比如因为没有处理好竞争条件），就会导致内存永久无法被回收
3.  引用计数法回收内存会产生碎片，当然碎片不是只有引用计数法才有的问题，所有的 GC 都需要面对碎片。

### Root Tracing 算法

Root Tracing 的原理是：从引用路径上，如果一个对象的引用链中包括一个根对象（Root Object），那么这个对象就是活动的。根对象是所有引用关系的源头。比如用户在栈中创建的对象指针；程序启动之初导入数据区的全局对象等。

Root Tracing 算法，这是一类算法，包括标记-清除算法和 3 色标记-清除算法。

#### 标记-清除（Mark Sweep）算法（双色标记清除）（V8）

标记-清除算法中，用白色代表一种不确定的状态：可能被回收。 黑色代表一种确定的状态：不会被回收。算法的实现，就是为所有的对象染色。算法执行结束后，所有是白色的对象就需要被回收。<br>
（标记清除 Mark-Sweep）-（标记整理 Mark-Compact）<br>
首先它会遍历堆上的所有的对象，分别对它们打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。
标记整理的处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存。<br>

GC 过程中 3 个动作

1.  标记程序（Mark）
2.  清除程序（Sweep）
3.  变更程序（Mutation）

// 标记（Mark）就是找到不用的内存，清除（Sweep）就是回收不用的资源，而修改（Mutation）则是指用户程序对内存进行了修改。<br>

存在问题：

1.  假设用户程序和 GC 交替执行，用户程序不断进行修改（Mutation），而 GC 不断执行标记-清除算法。那么这中间会产生大量浮动垃圾影响 GC 的效果。
2.  考虑到 GC 是一个非常消耗性能程序，我们希望 GC 能够增量回收。 比如说，用户仅仅是高频删除了一部分对象，那么是否可以考虑设计不需要从整个 Root 集合进行遍历，而是增量的只处理最近这一批变更的算法呢？我们平时可以多执行增量 GC，偶尔执行一次全量 GC。

PS：浮动垃圾（Floating Garbage）：在并发清除时,用户线程新产生的垃圾（不能在本次 GC 回收），称为浮动垃圾。
V8 在什么时候整理老生代的内存，在清理阶段会产生许多空隙片段，当这些空隙片段不能存放新生代转老生代所需要的空间时才会整理

#### 三色标记-清除算法（Tri-Color Mark Sweep）（JVM）

该算法是在”标记-清除“算法基础上增加一种灰色标记，把灰色看作可以增量处理的工作。

黑、白、灰三种颜色的含义

1.  白色代表需要 GC 的对象；
2.  黑色代表确定不需要 GC 的对象；
3.  灰色代表可能不需要 GC 的对象，但是还未完成标记的任务，也可以认为是增量任务。

// 算法需要维护 3 个集合，白色集合、黑色集合、灰色集合。3 个集合是互斥的，对象只能在一个集合中。

算法步骤

```
// 全量GC
在三色标记-清除算法中，一开始所有对象都染成白色。初始化完成后，会启动标记程序。在标记的过程中，是可以暂停标记程序执行 Mutation。
第一次执行，算法将 Root 集合能直接引用的对象加入灰色集合。
接下来算法会不断从灰色集合中取出元素进行标记（标记的过程主要分为 3 个步骤）。
1.  如果对象在白色集合中，那么先将对象放入灰色集合；
2.  然后遍历节点的所有的引用对象，并递归所有引用对象；
3.  当一个对象的所有引用对象都在灰色集合中，就把这个节点放入为黑色集合。
当标记算法执行完成的时候，所有不需要 GC 的元素都会涂黑；标记算法完成后，白色集合内就是需要回收的对象。
----以上，是类似双色标记-清除算法的全量 GC 程序----

// 增加 GC（Incremental GC）
首先对用户的修改进行分类，有这样 3 类修改（Mutation）需要考虑：
1.  创建新对象
2.  删除已有对象
3.  调整已有引用
如果用户程序创建了新对象，可以考虑把新对象直接标记为灰色。虽然，也可以考虑标记为黑色，但是标记为灰色可以让 GC 意识到新增了未完成的任务。比如用户创建了新对象之后，新对象引用了之前删除的对象，就需要重新标记创建的部分。
如果用户删除了已有的对象，通常做法是等待下一次全量 Mark 算法处理（完全可以接受的）。
```

### 如何理解内存溢出？

内存回收就好比有人在随手扔垃圾，清洁工需要不停打扫。如果清洁工能够跟上人们扔垃圾的速度，那么就不需要太多的 STL（Stop The World）。如果清洁工跟不上扔垃圾的速度，最终环境就会被全部弄乱，这个时候清洁工就会要求“Stop The World”。三色算法的优势就在于它支持多一些情况的 Mutation，这样能够提高“垃圾”被并发回收的概率。

[GC-三色标记算法原理](../html/GC-三色标记算法原理.html)

### old Space 分类

1.  old object space 即大家口中的老生代，不是全部老生代，这里的对象大部分是由新生代晋升而来
2.  large object space 大对象存储区域，其他区域无法存储下的对象会被放在这里，基本是超过 1M 的对象，这种对象不会在新生代对象中分配，直接存放到这里
3.  Map space 它是存储对象的映射关系的，其实就是隐藏类，啥是隐藏类
4.  code space 简单点说，就是存放代码的地方，编译之后的代码，是根据大佬们写的代码编译出来的代码

## 新生代晋升为老生代

1.  新生代中的对象是否已经经历过一次 Scavenge 算法（新生代垃圾回收算法）
2.  当一个对象，在被复制的时候，大于 to space 空间的 25% 的时候<br>
    引用类型是在没有引用之后, 通过 v8 的 GC 自动回收, 值类型如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 (new space) 切换的时候回收.

ps：新晋升的对象，直接标记为黑色，这是因为新晋升的对象存活下来的概率非常高，就算是不再使用，再下下次的时候也会被清除掉。

[V8 引擎垃圾内存回收原理解析](https://juejin.im/post/5dcb7f706fb9a04aad01615a)

## V8 写屏障

解决问题：当 GC 想回收新生代中的内容的时候，某些对象，恰好是一个老生代那边对象指过来的指针指向了它。
其实就是缓存列表，这个列表内记录了所有老生代指向新生代的情况，相当于记录下了那些新生代对象被老生代对象引用。
在新生代中触发 GC 遇到这样的对象的时候，会首先读一下缓存列表，这相比遍历老生代所有的对象，代价实在是太小了。

## 全停顿（stop-the-world）

产生的原因：新/老生带都包括在内，为了保证逻辑和垃圾回收的情况不一致，需要停止 JS 的运行，专门来遍历去遍历/复制，标记/清除，这个停顿就是：全停顿。
由于新生代比较小，所以执行一次时间比较短，但老生代比较大，全量执行一次会比较耗时。
具体做了下面三件事：

### 增量标记

将原来一口气去标记的事情，做成分步去做，每次内存占用达到一定的量或者多次进入写屏障的时候，就暂时停止 JS 程序，做一次最多几十毫秒的标记 marking，当下次 GC 的时候，反正前面都标记好了，开始清除就行了

### 并行回收

从字面意思看并行，就是在一次全量垃圾回收的过程中，就是 V8 引擎通过开启若干辅助线程，一起来清除垃圾，可以极大的减少垃圾回收的时间

### 并发回收

并发就是在 JS 主线程运行的时候，同时开启辅助线程，清理和主线程没有任何逻辑关系的垃圾，当然，需要写屏障来保障

# 逃逸分析(Escape Analysis）

## 逃逸

逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被 GC 回收，由于其被其它变量引用（不能被 GC 回收，则这个分配的对象"逃逸(escape)"了）。

## 逃逸分析所做的优化

V8 在 JavaScript 堆上分配新对象，使用逃逸分析，当 V8 分析出此对象只在函数内部起作用（和函数有相同的生命周期），则 V8 可以把对象分配到栈上，甚至可以把某些变量分配到寄存器中，把对象作为一个简单的局部变量，如果对象逃逸了，则必须在堆上分配。

# 图解 V8

## 对象属性的优化

ECMAScript 规范中定义了数字属性（elements）应该按照索引值大小升序排列，字符串属性（properties）根据创建时的顺序升序排列。<br>
字符串属性的存储方式为先写入的直接放在对象内（容量为 10），剩下的如果不是太多属性则用线性的存储模式，如果太多或存在反复添加或者删除属性的操作将使用非线性的字典存储模式。<br>

### 查看 Memory Snapshot

```
elements：按照索引值大小升序排列
properties：按照创建时的顺序升序排列（前 10 个直接放在对象上）
__proto__：属性就是原型，是用来实现 JavaScript 继承的
map：隐藏类，用于缓存属性达到快速访问的目的
```

## V8 优化

Ignition，解释器可以快速生成字节码，但字节码通常效率不高。TurboFan，优化编译器虽然需要更长的时间进行处理，但最终会产生更高效的机器码，这正是 V8 在使用的模型。
V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。

> 参考文档：
> [v8 知识点/V8 内部类继承层次](http://www.360doc.com/content/17/1019/20/43931101_696459755.shtml) > [Google V8 读码索引](https://www.open-open.com/pdf/81590b961df7453ea13b25d4c9e31231.html) > [JavaScript-V8 引擎](https://juejin.im/post/5d86496be51d453bdb1d9c11) > [Shapes 和 Inline Caches](https://zhuanlan.zhihu.com/p/38202123)
