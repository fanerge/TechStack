# V8 工作原理

V8 is Google's open source JavaScript engine.

## Handle

handle 是指向对象的指针，在 V8 中，所有的对象都通过 handle 来引用，handle 主要用于 V8 的垃圾回收机制。<br>
handle 分为两种：持久化 (Persistent)handle 和本地 (Local)handle，持久化 handle 存放在堆上，而本地 handle 存放在栈上。<br>
在 V8 中，所有数据访问均需要通过 handle。<br>

### 在 C++中栈 Stack 和堆 Heap

Stack：栈上的为自动变量，在退出函数或方法之后自动被释放。<br>
Heap：堆上的空间需要开发人员自己申请，使用完成之后显式的释放。<br>

## HandleScope

一个函数中，可以有很多 Handle，而 HandleScope 则相当于用来装 Handle（Local）的容器，当 HandleScope 生命周期结束的时候，Handle 也将会被释放，会引起 Heap 中对象引用的更新。<br>
HandleScope 是分配在栈上，不能通过 New 的方式进行创建。对于同一个作用域内可以有多个 HandleScope，新的 HandleScope 将会覆盖上一个 HandleScope，并对 Local Handle 进行管理。<br>

## Context

Context 是 V8 中一个非常重要的类。<br>
Context 中包了 JavaScript 内建函数、对象等。<br>
context 是一个执行器环境，使用 context 可以将相互分离的 JavaScript 脚本在同一个 V8 实例中运行，而互不干涉。在运行 JavaScript 脚本时，需要显式的指定 context 对象。

## 数据及模板

由于 C++ 原生数据类型与 JavaScript 中数据类型有很大差异，
因此 V8 提供了 Data 类，从 JavaScript 到 C++，从 C++ 到 JavaScrpt 都会用到这个类及其子类。<br>
V8 中，有两个模板 (Template) 类：对象模板 (ObjectTempalte) 和函数模板 (FunctionTemplate):<br>
ObjectTemplate：将 C++ 中的对象暴露给脚本环境<br>
FunctionTemplate：将 C++ 函数暴露给脚本环境，以供脚本使用

## V8 引擎的应用程序的基本流程

1.  创建 HandleScope 实例
2.  创建一个持久化的 Context
3.  进入 Context
4.  创建脚本字符串（这里就是我们的 js 代码）
5.  创建 Script 对象，通过 Script::Compile()
6.  执行脚本对象的 Run 方法
7.  获取处理结果
8.  显式的调用 Context 的 Dispose 方法

## TurboFan & Ignition

其中 Turbofan 是新的优化编译器，而 Ignition 则是新的解释器。

[Google V8 引擎 原理详解](https://blog.csdn.net/jklfjsdj79hiofo/article/details/7842177)

# 对象（Object）

## 对象两种访问模式

### Dictionary(Slow) Mode

字典模式也称为哈希表模式，V8 使用哈希表来存储对象的属性。

### Stable(Fast) Mode

使用类似数组（C Struct）结构来存储对象的属性并使用 Offset 进行访问。

### 访问模式切换

#### 快速模式切换至字典模式

1.  当动态地添加太多属性
2.  删除属性（删除非最后添加的属性 V8 >= 6.0）
3.  使用不合法标识符命名属性

#### 字典模式切换至快速模式

1.  调用 Runtime Call (%ToFastProperties)
2.  当对象被设置成为一个函数（或对象）的原型
    [奇技淫巧学 V8 之一，对象访问模式优化](https://zhuanlan.zhihu.com/p/28777722)

## 对象在 V8 内的表达

### 对象存储空间分配

1.  预分配（不超过）一定大小（252）的空间用作对象内属性存储（inobject_properties）。
2.  预分配空间不足时（无空闲 slot），新增属性会存储在 properties 内。
3.  数字式属性存储在 elements 内。
4.  properties/elements 空间不足时会创建（拷贝）一个更大的 FixedArray。
    V8 的对象主要由三个指针构成，分别是隐藏类（Hidden Class、Shape），Property 还有 Element。<br>
    [奇技淫巧学 V8 之二，对象在 V8 内的表达](https://zhuanlan.zhihu.com/p/28780798)

### Hidden class（Shape）

引擎将对象的 Shape 与对象值分开存储。<br>
V8 会为每个对象初始化时附加一个隐藏类，隐藏类的目的是优化属性访问时间，当添加一个属性时（非索引属性），会产生一个新的隐藏类，该隐藏类继承至原先的隐藏类。<br>
主要为类似的对象（同一构造函数、类的实例，主要是保证相同的顺序初始化对象成员）提供相同的 Shape，用来提升属性的存取性能。<br>
每次添加属性时，新创建 Hidden Class 实际上只会描述这个新添加的属性（增加或删除可索引属性，不会引起隐藏类的变化）。<br>
delete 非索引属性可以会产生新的 Hidden Class ，而 obj[待删除的属性] = undefined 不会 <br>
[8 中的 Javascript 隐藏类和内联缓存](https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html)

#### Hidden Class 如何优化了对象属性的访问性能？

1.  Hidden Class 描述了可以找到属性的内存中的位置（相对于对象指针），V8 把属性 field 的按名字访问，抹掉名字信息，变成按 offset 访问。
2.  如果两个对象添加属性的顺序相同，则他们共用一个 Hidden Class，这样就可以快速访问属性
3.  每次新增属性会在原来的 Hidden Class 基础上新建一个 Hidden Class（这样就形成了 shape 链或树），Hidden Class 只记录了当前属性 offset 及除[[value]]以外的属性

### Elements

可索引属性会被存储到 Elements 指针指向的区域（遍历时会自动按升序）<br>

```
{ 1: "a", 2: "b" }
```

### Properties

命名属性会被存储到 Properties 指针指向的区域（会按写入对象的顺序）<br>

```
{ "first": 1, "second": 2 }
```

[V8 是怎么跑起来的 —— V8 中的对象表示](https://juejin.im/post/5cc7dc5af265da038d0b514d)

## Inline Cache（内联缓存）

### 定义

内联缓存（Inline caching）是部分编程语言的运行时系统采用的优化技术，最早为 Smalltalk 开发。内联缓存的目标是通过记住以前直接在调用点上方法查询的结果来加快运行时方法绑定的速度。内联缓存对动态类型语言尤为有用，其中大多数（如非全部）方法绑定发生在运行时，因此虚方法表通常无法使用。<br>
内联缓存分为：单态内联缓存、多态内联缓存、变形内联缓存，单态调用（MONOMORPHIC）性能优于多态（POLYMORPHIC）与复态（MEGAMORPHIC）！<br>

### 单态内联缓存、多态内联缓存、变形内联缓存转换关系

区别：对于特定调用（callsite） 来说 receiver 类型（shape）数量不同，而呈现不同状态。<br>

```
当 IC 刚被创建时为初态（没有调用过），没有接收到任何一种类型信息。
当被调用时：
如果接收到 1 种类型信息会迁移到单态模式（MONOMORPHIC）。
收到大于 1 种小于 4 种类型信息会迁移到多态模式（POLYMORPHIC）。
当接收到大于 4 种类型信息时会迁移到复态模式（MEGAMORPHIC）。
```

PS：kMaxKeyedPolymorphism = 4，所以多态与复态模式模式的界限在接收到 4 种类型信息时。

### 工作原理

Shapes 背后的主要动机是 Inline Caches 或 ICs 的概念，JS 引擎为了提高对象查找效率，需要在局部做高效缓存。<br>
如在对象上读属性时第一次去查找 shape 链，找到相应属性的 offset，再次访问属性，只要 Shape 相同，引擎直接从指令中缓存的下标中可以直接命中要查找的值，而这个缓存在指令中的下标就是 Inline Cache 下次直接使用。

```
// 对象 a 和 b 拥有相同的 shape（记录了当前属性offset及除[[value]]以外的属性）
var a = {x: 'yzf'};
var b = {x: 'wkm'};
// 定义访问对象属性的方法
function getX(point) {
  // point.x称为 callsite
  return point.x;
}
// 我们把 point.x 称之为一个 callsite，把 "x" 称之为一条名为 "x" 的消息，而实际执行的 point （无论是 {x : 1}，还是 {x : 1, y : 2}）称之为这个 callsite 的 receiver。
// 初次访问 x 属性，在 shape 链或树找到对 x 属性的描述offset，并缓存起来（Inline Cache）
getX(a);
// 再次访问其他对象的 x 属性，不需要再查找 shape 链或树，直接命中要查找的值
getX(b);
```

### 内联缓存和 Hidden Class 需要配合工作

每当在特定对象上调用方法时，V8 引擎必须执行对该对象隐藏类的查找，以确定访问特定属性的偏移量。在将同一方法成功调用两次到同一个隐藏类之后，V8 省略了隐藏类查找，只是将属性的偏移量添加到对象指针本身。对于该方法的所有未来调用，V8 引擎假定隐藏类未更改，并使用先前查找中存储的偏移直接跳转到特定属性的内存地址; 这大大提高了执行速度。
[内联缓存](https://zh.wikipedia.org/wiki/%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98)
[奇技淫巧学 V8 之三，多态内联缓存 PICs](https://zhuanlan.zhihu.com/p/28790195)

## 对象优化

始终以相同的顺序实例化对象属性，以便可以共享隐藏的类和随后优化的代码。<br>
在实例化之后向对象添加属性将强制隐藏类更改并减慢为先前隐藏类优化的任何方法。而是在其构造函数中分配所有对象的属性。<br>
沿着属性添加的反方向删除属性时，对象不会退化为字典模式。<br>
重复执行相同方法的代码将比仅执行许多不同方法的代码运行得更快（由于内联缓存）。<br>

# 原型优化（prototype）

引擎将原型链在 Shape 上，而不是直接链在实例上。<br>
V8 专门为此目的处理原型的 shape。每个原型都具有一个不与其他对象（特别是不与其他原型共享）共享且独特的 shape，且每个原型的 shape 都具有与之关联的一个特殊 ValidityCell。<br>
只要有人更改相关原型或其祖先的任何原型，此 ValidityCell 就会失效。<br>
第一次运行此代码预热 inline cache 时，V8 会记住目标属性在原型中的偏移量。下次 inline cache 命中时，引擎必须检查实例的 shape 和 ValidityCell。如果 ValidityCell === true，则引擎可以直接到达 Prototype 上的 Offset 位置，跳过其他查找。如果它 ValidityCell === false，引擎将重复上面的操作。<br>

## 优化

1. 请勿随意修改原型对象（这样是使引擎的优化手段失效）
2. 你实在需要修改原型，那么请在其他代码运行之前做这件事

[JavaScript 引擎基础：原型优化](https://zhuanlan.zhihu.com/p/42630183)

# 数组（Array）

## V8 引擎将 JavaScript 数组分为两类

### FixedArray

FixedArray，使用连续的内存进行存储，可以使用索引直接定位，新创建的空数组默认为 FixedArray 类型，当数组超过最大长度会进行动态地扩容；

### HashTable

HashTable，以哈希表的形式存储在内存空间里，存储地址不连续，与 FixedArray 类型相比，性能相对较差。

### 两者之间在实际使用时可以相互转换

FixedArray 转 HashTable，当新增元素的索引值相对于数组长度大于等于 1024 或者新容量 >= 3 × 扩容后的容量 × 2；
HashTable 转 FixedArray，当 HashTable 数组的元素可存放在 FixedArray 数组中且长度在 smi 之间且仅节省了 50% 的空间时发生转换，其中 smi 值在不同操作系统下有所不同。

## TimSort 排序

Array.prototype.sort() 函数的底层实现算法 TimSort。<br>
JavaScript 引擎把高效的排序算法写入数组的原型函数 sort 中了，这种高效的排序算法就是 TimSort。<br>
TimSort 同时采用了折半插入排序和归并排序。<br>
时间复杂度可以达到 O(n)，最坏的情况下也能达到 O(nlogn)，空间复杂度在最好情况和最坏情况下分别为 O(1) 和 O(n)。

## 数组存储模式

Fast Elements 是传统的线性存储方式，而 Dictionary Elements 使用的是 Hash 表存储。<br>
Fast Elements：该模式为默认模式，对于一个新创建的数组赋值时，数组的存储空间是可以动态增长的。<br>
Fast Holey Elements：还有一种子模式 Fast Holey Elements，此模式适合于数组中只有某些索引存有元素，而其他的索引都没有赋值的情况（访问时引擎会返回 undefined）。<br>
Dictionary Elements：此方式最适合于存储稀疏数组，它不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 Hash-Table。<br>

## 存储模式切换

其上的几种模式 V8 引擎可以自由切换。<br>
在 Fast Elements 模式下，capacity 用于指示当前内存占用量大小，通常根据数组当前最大索引的值确定。在数组索引过大，超过 capacity 到一定程度( 由 kMaxGap 决定，其值为 1024) ，数组将 直接转化为 Dictionary Elements 模式

## 数组性能优化

避免使用负整数作为索引<br>
预先指定数组大小<br>
避免使用不连续的索引值<br>
避免逆序对数组赋值<br>
避免读数超出数组的长度！这样 V8 会在原型链上去找这个属性。<br>
避免产生 holey 数组（如 new Array(100)），v8 对密集数组做了更多优化。<br>
[V8 引擎中的 JavaScript 数组实现分析与性能优化](https://blog.csdn.net/xiebaochun/article/details/85711635)

# 字符串（String）

## v8 中字符串 5 种表达模式

### SeqString

在 V8 堆内使用（类似数组的）连续空间存储字符串。
实际数据存储时分为 OneByte(全是单字节字符)、TwoByte(有双字节字符)（Unicode）两类。

### ConsString(first, second)

在字符串拼接时，采用树形结构表达拼接后（first + second）的字符串。

### SliceString(parent, offset)

在字符串切割时，采用 offset 与 [length] 表达父字符串（parent）的一部分。

### ThinString(actual)

直接引用另一个字符串对象（actual）。
在多数情况下可以被认为与 ConsString(actual, empty_string) 等价。

### ExternalString

代表了产生在 V8 堆外的字符串资源。
实际数据表达时分为 OneByte、TwoByte（Unicode）两类。<br>
所有的表达模式均有 [length] 属性（由基类 String 定义）记录了字符串中的字符数（UTF-16 单元数），但只有 SeqString 真正存储了字符数据，而 ConsString 、SliceString 、ThinString 均为其它表达模式的引用（不存储字符数据）。

## 字符串性能优化

字符串的表达方式大多与其构造方式有关。<br>
字符串拼接时，比起重新分配一个空间进行存储，采用树形结构（ConsString）表达更加高效。<br>
字符串在最终输出前调用 Number 方法来扁平化，可以提高后续操作的性能。<br>
将字符串被设置为对象属性名时，会被尝试改造为常量化版本。

[奇技淫巧学 V8 之六，字符串在 V8 内的表达](https://zhuanlan.zhihu.com/p/28883711)

# 数字（Number）

JavaScript 值，V8 仍需要对不同类型值应用特定的内存表示方式。

### 三种存储方式

Smi vs HeapNumber vs MutableHeapNumber<br>

#### Smi

范围：64 位-2³¹ 到 2³¹-1<br>
Smi:immediate small integer<br>
31 位有符号位范围内的整型数字都用 Smi 表示法。
当使用 Smi 内的数字时，引擎不需要为其分配专门的内存实体，并会启用快速整型操作。<br>

#### HeapNumber

浮点数会用 HeapNumber 表示。
非 Smi 范围内的数字被定义为 HeapNumber，HeapNumber 是一种特殊的 HeadObject。<br>

#### MutableHeapNumber

```
const o = {
  x: 42,  // Smi，会被当成Smi直接存储在对象本身
  y: 4.2, // HeapNumber，o.y中的4.2需要额外开辟一个内存实体存放，并将o.y的对象指针指向该内存实体
  z: 5.2 // HeapNumber
};

// 对象操作
o.x = o.x + 10; // o.x = 52,o.x的值会被原地更新，因为新的值52仍在Smi范围中。
o.y += 1; // 而HeapNumber是不可变的，当我们改变o.y的值为5.2时，V8 需要再开辟一个新的内存实体给到o.y引用。
for (let i = 0; i < 5; ++i) {
  // 创建一个额外的`HeapNumber`对象
  o.z += 1; // 优化后编程了一个MutableHeapNumber实例
}
// 为了防止这个问题（每次循环都创建HeapNumber实例），V8 提供了一种优化方式去原地更新非Smi的值：当一个数字内存区域拥有一个非Smi范围内的数值时，V8 会将这块区域标志为Double区域，并会为其分配一个用 64 位浮点表示的MutableHeapNumber实例。
o.w = o.z;
// 当o.z被共享时，o.z内的MutableHeapNumber需要被重新封装成HeapNumber
```

# JIT 和 AOT

## AOT

AOT：静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为 AOT （Ahead of time）即 “提前编译”，代表 C/C++。

## JIT

JIT：解释执行的则是一句一句边翻译边运行，通常将这种类型称为 JIT（Just-in-time）即“即时编译”，代表 JavaScript、python。

事实上所有脚本语言都支持 JIT 模式。但需要注意的是 JIT 和 AOT 指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以 JIT 方式运行也可以以 AOT 方式运行，如 Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码。

# V8 的内存分配（垃圾回收）

以 64 位为例子：V8 能够获得 1.4G<br>
垃圾回收会终止程序执行。

```
// 这是调整新生代这部分的内存，单位是 KB。
node --max-new-space-size=2048 xxx.js
// 这是调整老生代这部分的内存，单位是MB
node --max-old-space-size=2048 xxx.js
```

## V8 为什么要给它设置内存上限？

1.  JS 单线程的执行机制（这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停）
2.  JS 垃圾回收机制的限制（垃圾回收其实是非常耗时间的操作，采用增量标记方式得以缓解）

## 新生代内存（算法名 Scavenge 算法）

新生代内存空间（短时间存在的，如局部变量）：64MB<br>
垃圾回收算法：遍历标记，标记即将回收的对象，复制未标记的对象，交换空间

1.  首先，V8 引擎中的垃圾回收器检测到 from space 空间快达到上限了，此时要进行一次垃圾回收了
2.  然后，从根部开始遍历，不可达对象(即无法遍历到的对象)将会被标记，并且复制未被标记的对象，放到 to space 中
3.  最后，清除 from space 中的数据，同时将 from space 置为空闲状态，即变成 to space，相应的 to space 变成 from space，俗称翻转

## old Space 回收

### 三色标记法

V8 中分配的每一个内存页中创建了一个 marking bitmap 坑位，这个坑位用于颜色标记。
白：未被标记的对象，即不可达对象（没有扫描到的对象），可回收
灰：已被标记的对象（可达对象），但是对象还没有被扫描完，不可回收
黑：已被扫描完（可达对象），不可回收

1.  首先将所有的非根部对象全部标记为白色，然后使用（深度优先遍历），和新生代（广度优先遍历），按深度优先搜索沿途遍历，将访问到的对象，直接压入栈中，同时将标记结果放在 marking bitmap (灰色) 中，一个对象遍历完成，直接出栈，同时在 marking bitmap 中记录为黑色，直到栈空为止
2.  标记完成后，接下来就是等待垃圾回收器来清除了，清除完了之后，会在原来的内存区域留下一大堆不连续的空间，小对象还好说，这个时候如果来一个稍微大一点的对象，可能就没有连续的内存来存放了
3.  所以在清除完之后，新生代中对象，再一次分配到老生带并且内存不足的时候，会优先触发标记整理（mark-compact）, 在标记结束后，他会将可达对象(黑色)，移到内存的另一端，其他的内存空间就不会被占用，直接释放，等下次再有对象晋升的时候

PS：V8 在什么时候整理老生代的内存，在清理阶段会产生许多空隙片段，当这些空隙片段不能存放新生代转老生代所需要的空间时才会整理

### old Space 分类

1.  old object space 即大家口中的老生代，不是全部老生代，这里的对象大部分是由新生代晋升而来
2.  large object space 大对象存储区域，其他区域无法存储下的对象会被放在这里，基本是超过 1M 的对象，这种对象不会在新生代对象中分配，直接存放到这里
3.  Map space 它是存储对象的映射关系的，其实就是隐藏类，啥是隐藏类
4.  code space 简单点说，就是存放代码的地方，编译之后的代码，是根据大佬们写的代码编译出来的代码

## 新生代晋升为老生代

1.  新生代中的对象是否已经经历过一次 Scavenge 算法（新生代垃圾回收算法）
2.  当一个对象，在被复制的时候，大于 to space 空间的 25% 的时候<br>
    引用类型是在没有引用之后, 通过 v8 的 GC 自动回收, 值类型如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 (new space) 切换的时候回收.

ps：新晋升的对象，直接标记为黑色，这是因为新晋升的对象存活下来的概率非常高，就算是不再使用，再下下次的时候也会被清除掉。

[V8 引擎垃圾内存回收原理解析](https://juejin.im/post/5dcb7f706fb9a04aad01615a)

## V8 写屏障

解决问题：当 GC 想回收新生代中的内容的时候，某些对象，恰好是一个老生代那边对象指过来的指针指向了它。
其实就是缓存列表，这个列表内记录了所有老生代指向新生代的情况，相当于记录下了那些新生代对象被老生代对象引用。
在新生代中触发 GC 遇到这样的对象的时候，会首先读一下缓存列表，这相比遍历老生代所有的对象，代价实在是太小了。

## 全停顿（stop-the-world）

产生的原因：新/老生带都包括在内，为了保证逻辑和垃圾回收的情况不一致，需要停止 JS 的运行，专门来遍历去遍历/复制，标记/清除，这个停顿就是：全停顿。
由于新生代比较小，所以执行一次时间比较短，但老生代比较大，全量执行一次会比较耗时。
具体做了下面三件事：

### 增量标记

将原来一口气去标记的事情，做成分步去做，每次内存占用达到一定的量或者多次进入写屏障的时候，就暂时停止 JS 程序，做一次最多几十毫秒的标记 marking，当下次 GC 的时候，反正前面都标记好了，开始清除就行了

### 并行回收

从字面意思看并行，就是在一次全量垃圾回收的过程中，就是 V8 引擎通过开启若干辅助线程，一起来清除垃圾，可以极大的减少垃圾回收的时间

### 并发回收

并发就是在 JS 主线程运行的时候，同时开启辅助线程，清理和主线程没有任何逻辑关系的垃圾，当然，需要写屏障来保障

# 逃逸分析(Escape Analysis）

## 逃逸

逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被 GC 回收，由于其被其它变量引用（不能被 GC 回收，则这个分配的对象"逃逸(escape)"了）。

## 逃逸分析所做的优化

V8 在 JavaScript 堆上分配新对象，使用逃逸分析，当 V8 分析出此对象只在函数内部起作用（和函数有相同的生命周期），则 V8 可以把对象分配到栈上，甚至可以把某些变量分配到寄存器中，把对象作为一个简单的局部变量，如果对象逃逸了，则必须在堆上分配。

# 图解 V8

## 对象属性的优化

ECMAScript 规范中定义了数字属性（elements）应该按照索引值大小升序排列，字符串属性（properties）根据创建时的顺序升序排列。<br>
字符串属性的存储方式为先写入的直接放在对象内（容量为 10），剩下的如果不是太多属性则用线性的存储模式，如果太多或存在反复添加或者删除属性的操作将使用非线性的字典存储模式。<br>

### 查看 Memory Snapshot

```
elements：按照索引值大小升序排列
properties：按照创建时的顺序升序排列（前 10 个直接放在对象上）
__proto__：属性就是原型，是用来实现 JavaScript 继承的
map：隐藏类，用于缓存属性达到快速访问的目的
```

## V8 优化

Ignition，解释器可以快速生成字节码，但字节码通常效率不高。TurboFan，优化编译器虽然需要更长的时间进行处理，但最终会产生更高效的机器码，这正是 V8 在使用的模型。
V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。

> 参考文档：
> [v8 知识点/V8 内部类继承层次](http://www.360doc.com/content/17/1019/20/43931101_696459755.shtml) > [Google V8 读码索引](https://www.open-open.com/pdf/81590b961df7453ea13b25d4c9e31231.html) > [JavaScript-V8 引擎](https://juejin.im/post/5d86496be51d453bdb1d9c11) > [Shapes 和 Inline Caches](https://zhuanlan.zhihu.com/p/38202123)
